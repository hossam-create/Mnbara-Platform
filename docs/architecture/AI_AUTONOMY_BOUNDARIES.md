# AI Autonomy Boundaries - Technical Constraints

## ⛔ ABSOLUTE PRINCIPLE

**AI in this system is ADVISORY ONLY. It cannot execute, approve, or finalize ANY action.**

This document defines the hard technical boundaries that make AI autonomy architecturally impossible.

---

## Part 1: Hard-Coded Constraints

### 1.1 Type System Enforcement

```typescript
// AI outputs are ALWAYS typed as advisory - never executable
interface AIOutput {
  readonly type: 'ADVISORY';  // Literal type - cannot be changed
  readonly recommendation: Recommendation;
  readonly confidence: number;
  readonly reasoning: string;
  
  // These fields DO NOT EXIST on AI outputs
  // execute?: never;
  // approve?: never;
  // finalize?: never;
}

// Execution requires HUMAN input - type system enforces this
interface ExecutionRequest {
  readonly humanConfirmation: HumanConfirmation;  // REQUIRED
  readonly advisoryId: string;                     // Links to AI output
  readonly userId: string;                         // Human who confirmed
  readonly confirmationTimestamp: Date;            // When human confirmed
  readonly twoFactorToken: string;                 // 2FA proof
}

// HumanConfirmation cannot be generated by AI
interface HumanConfirmation {
  readonly source: 'USER_INPUT';  // Literal - cannot be 'AI' or 'SYSTEM'
  readonly inputMethod: 'BUTTON_CLICK' | 'FORM_SUBMIT' | 'BIOMETRIC';
  readonly deviceFingerprint: string;
  readonly sessionId: string;
}
```

### 1.2 Function Signature Constraints

```typescript
// AI services ONLY return recommendations - no side effects
class AIAdvisoryService {
  // ✅ ALLOWED: Pure functions that return data
  async getRecommendation(input: AdvisoryInput): Promise<AIOutput> {
    // Read-only operations only
    return { type: 'ADVISORY', ... };
  }
  
  async classifyIntent(input: IntentInput): Promise<IntentClassification> {
    // Read-only operations only
    return { type: 'ADVISORY', ... };
  }
  
  async assessRisk(input: RiskInput): Promise<RiskAssessment> {
    // Read-only operations only
    return { type: 'ADVISORY', ... };
  }
  
  // ⛔ FORBIDDEN: These methods DO NOT EXIST
  // async execute(...): Promise<any>
  // async approve(...): Promise<any>
  // async transfer(...): Promise<any>
  // async debit(...): Promise<any>
  // async credit(...): Promise<any>
}
```

### 1.3 Database Permission Constraints

```sql
-- AI service database user has READ-ONLY permissions
CREATE USER ai_service_user WITH PASSWORD '***';

-- GRANT only SELECT on specific tables
GRANT SELECT ON users TO ai_service_user;
GRANT SELECT ON transactions TO ai_service_user;
GRANT SELECT ON trust_scores TO ai_service_user;
GRANT SELECT ON listings TO ai_service_user;

-- EXPLICITLY DENY all write operations
REVOKE INSERT, UPDATE, DELETE ON ALL TABLES FROM ai_service_user;
REVOKE EXECUTE ON ALL FUNCTIONS FROM ai_service_user;

-- AI cannot access sensitive tables at all
REVOKE ALL ON payment_credentials FROM ai_service_user;
REVOKE ALL ON bank_accounts FROM ai_service_user;
REVOKE ALL ON escrow_accounts FROM ai_service_user;

-- Audit: AI service queries are logged separately
CREATE POLICY ai_audit_policy ON all_tables
  FOR SELECT
  TO ai_service_user
  USING (true)
  WITH CHECK (false);  -- Cannot modify
```


### 1.4 API Route Constraints

```typescript
// AI endpoints are GET-only (read operations)
// POST endpoints return advisory data, never execute actions

// ✅ ALLOWED AI ROUTES
router.get('/api/ai/advisory/:id', getAdvisory);           // Read advisory
router.post('/api/ai/advisory/request', requestAdvisory);  // Request new advisory (returns data)
router.get('/api/ai/trust-score/:userId', getTrustScore);  // Read trust score
router.get('/api/ai/risk-assessment/:id', getRiskAssessment);

// ⛔ FORBIDDEN ROUTES - These DO NOT EXIST in AI service
// router.post('/api/ai/execute', ...);
// router.post('/api/ai/approve', ...);
// router.post('/api/ai/transfer', ...);
// router.post('/api/ai/payment', ...);
// router.delete('/api/ai/*', ...);
// router.put('/api/ai/*', ...);
// router.patch('/api/ai/*', ...);

// Execution routes are in SEPARATE service with HUMAN gates
// backend/services/payment-service (NOT ai-core)
router.post('/api/payments/execute', requireHumanConfirmation, executePayment);
```

### 1.5 Environment Variable Constraints

```bash
# AI service environment - NO execution credentials
AI_SERVICE_DB_USER=ai_readonly_user
AI_SERVICE_DB_PASSWORD=***
AI_SERVICE_DB_READ_ONLY=true

# AI service DOES NOT have access to:
# - STRIPE_SECRET_KEY (payment execution)
# - PAYMOB_API_KEY (payment execution)
# - ESCROW_SIGNING_KEY (fund release)
# - BANK_API_CREDENTIALS (transfers)
# - PSP_WEBHOOK_SECRET (payment callbacks)

# These are ONLY in payment-service environment
# AI service cannot access them - different K8s secrets
```

---

## Part 2: Architectural Impossibilities

### 2.1 Service Isolation

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         SERVICE ISOLATION ARCHITECTURE                                   │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                          │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│   │                         AI CORE SERVICE (ISOLATED)                               │   │
│   │                                                                                   │   │
│   │  Network: ai-internal (no external access)                                       │   │
│   │  Database: READ-ONLY replica                                                     │   │
│   │  Secrets: NONE for execution                                                     │   │
│   │  Outbound: BLOCKED to payment providers                                          │   │
│   │                                                                                   │   │
│   │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │   │
│   │  │   Intent    │  │   Trust     │  │    Risk     │  │  Decision   │            │   │
│   │  │ Classifier  │  │   Scorer    │  │  Assessor   │  │ Recommender │            │   │
│   │  │  (READ)     │  │  (READ)     │  │  (READ)     │  │  (READ)     │            │   │
│   │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘            │   │
│   │                                                                                   │   │
│   │  OUTPUT: Advisory JSON only                                                      │   │
│   │  CANNOT: Call payment APIs, modify data, trigger webhooks                       │   │
│   └─────────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                          │
│   ════════════════════════════════════════════════════════════════════════════════════   │
│                              NETWORK BOUNDARY (NO DIRECT PATH)                           │
│   ════════════════════════════════════════════════════════════════════════════════════   │
│                                                                                          │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│   │                         EXECUTION SERVICE (SEPARATE)                             │   │
│   │                                                                                   │   │
│   │  Network: payment-internal (isolated from AI)                                    │   │
│   │  Database: READ-WRITE (primary)                                                  │   │
│   │  Secrets: Payment provider credentials                                           │   │
│   │  Outbound: Payment providers ONLY                                                │   │
│   │                                                                                   │   │
│   │  REQUIRES: Human confirmation token (cannot be generated by AI)                 │   │
│   │  VALIDATES: User session, 2FA, device fingerprint                               │   │
│   │                                                                                   │   │
│   └─────────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                          │
│   AI Service CANNOT:                                                                    │
│   • Call Execution Service directly (network blocked)                                   │
│   • Generate human confirmation tokens (cryptographically impossible)                   │
│   • Access payment credentials (different K8s namespace)                               │
│   • Modify database records (READ-ONLY user)                                           │
│                                                                                          │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```


### 2.2 Network Policy Enforcement

```yaml
# Kubernetes NetworkPolicy - AI service cannot reach execution endpoints
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: ai-service-isolation
  namespace: ai-core
spec:
  podSelector:
    matchLabels:
      app: ai-core
  policyTypes:
    - Ingress
    - Egress
  ingress:
    # Only accept requests from API gateway
    - from:
        - namespaceSelector:
            matchLabels:
              name: api-gateway
      ports:
        - port: 3000
  egress:
    # Can only reach read-replica database
    - to:
        - namespaceSelector:
            matchLabels:
              name: database-readonly
      ports:
        - port: 5432
    # Can reach Redis for caching
    - to:
        - namespaceSelector:
            matchLabels:
              name: cache
      ports:
        - port: 6379
    # BLOCKED: Cannot reach payment service
    # BLOCKED: Cannot reach external payment providers
    # BLOCKED: Cannot reach primary database
```

### 2.3 Cryptographic Impossibilities

```typescript
// Human confirmation tokens use asymmetric cryptography
// AI service does NOT have the private key

interface ConfirmationTokenPayload {
  userId: string;
  advisoryId: string;
  action: string;
  amount: number;
  timestamp: number;
  deviceFingerprint: string;
  sessionId: string;
}

// Token generation happens in AUTH SERVICE (not AI)
class ConfirmationTokenService {
  // Private key is in auth-service secrets ONLY
  private readonly privateKey: string;
  
  // This method is in AUTH SERVICE, not AI service
  generateToken(payload: ConfirmationTokenPayload): string {
    // Sign with private key that AI service cannot access
    return jwt.sign(payload, this.privateKey, {
      algorithm: 'RS256',
      expiresIn: '5m',
    });
  }
}

// Execution service validates with PUBLIC key
class ExecutionService {
  private readonly publicKey: string;
  
  validateConfirmation(token: string): ConfirmationTokenPayload {
    // Verify signature - AI cannot forge this
    return jwt.verify(token, this.publicKey, {
      algorithms: ['RS256'],
    });
  }
}

// WHY AI CANNOT FORGE TOKENS:
// 1. AI service does not have private key
// 2. Private key is in different K8s namespace
// 3. Token includes device fingerprint (from user's browser)
// 4. Token includes session ID (from auth service)
// 5. RS256 is cryptographically secure
```

### 2.4 Data Flow Impossibility

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                         DATA FLOW - AI CANNOT BYPASS HUMAN                               │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                          │
│   USER REQUEST                                                                          │
│        │                                                                                 │
│        ▼                                                                                 │
│   ┌─────────────┐                                                                       │
│   │ API Gateway │                                                                       │
│   └──────┬──────┘                                                                       │
│          │                                                                               │
│          ▼                                                                               │
│   ┌─────────────┐     Advisory Request      ┌─────────────┐                            │
│   │  Crowdship  │ ─────────────────────────▶│  AI Core    │                            │
│   │  Service    │                           │  Service    │                            │
│   │             │◀───────────────────────── │  (READ)     │                            │
│   └──────┬──────┘     Advisory Response     └─────────────┘                            │
│          │                                                                               │
│          │ Returns advisory to user                                                     │
│          ▼                                                                               │
│   ┌─────────────┐                                                                       │
│   │    USER     │  ◀── User sees recommendation                                        │
│   │  (HUMAN)    │                                                                       │
│   └──────┬──────┘                                                                       │
│          │                                                                               │
│          │ User MUST click confirm button                                               │
│          │ User MUST enter 2FA                                                          │
│          │ User MUST be on verified device                                              │
│          ▼                                                                               │
│   ┌─────────────┐                                                                       │
│   │    Auth     │  Generates confirmation token                                        │
│   │   Service   │  (AI cannot access private key)                                      │
│   └──────┬──────┘                                                                       │
│          │                                                                               │
│          │ Token + User confirmation                                                    │
│          ▼                                                                               │
│   ┌─────────────┐                                                                       │
│   │  Execution  │  Validates token signature                                           │
│   │   Service   │  Executes if ALL checks pass                                         │
│   └─────────────┘                                                                       │
│                                                                                          │
│   ⛔ AI CANNOT:                                                                         │
│   • Skip the user confirmation step                                                     │
│   • Generate valid confirmation tokens                                                  │
│   • Call execution service directly                                                     │
│   • Modify the data flow                                                                │
│                                                                                          │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```


---

## Part 3: Safeguards Against Accidental Autonomy

### 3.1 Code Review Gates

```typescript
// MANDATORY code review rules (enforced by CI/CD)

// Rule 1: AI service files cannot import execution modules
// .eslintrc.json
{
  "rules": {
    "no-restricted-imports": ["error", {
      "patterns": [
        {
          "group": ["**/payment-service/**"],
          "message": "AI service cannot import payment execution code"
        },
        {
          "group": ["**/escrow-service/**"],
          "message": "AI service cannot import escrow execution code"
        },
        {
          "group": ["**/execution/**"],
          "message": "AI service cannot import any execution code"
        }
      ]
    }]
  }
}

// Rule 2: AI service cannot have write methods
// Custom ESLint rule
{
  "rules": {
    "ai-service/no-write-operations": ["error", {
      "forbiddenMethods": [
        "create", "update", "delete", "insert", "upsert",
        "execute", "transfer", "debit", "credit", "approve"
      ]
    }]
  }
}

// Rule 3: PR must have security review for AI changes
// CODEOWNERS
/backend/services/ai-core/** @security-team @ai-safety-team
```

### 3.2 Runtime Safeguards

```typescript
// Runtime assertion - AI output cannot trigger execution
class AIOutputValidator {
  validate(output: unknown): AIOutput {
    // Type guard ensures output matches advisory schema
    if (!this.isAdvisoryOutput(output)) {
      throw new AIOutputViolationError('AI output must be advisory type');
    }
    
    // Check for forbidden fields
    if ('execute' in output || 'approve' in output || 'transfer' in output) {
      // Log security incident
      this.securityLogger.critical({
        event: 'AI_AUTONOMY_VIOLATION_ATTEMPT',
        output,
        timestamp: new Date(),
      });
      
      // Alert security team immediately
      this.alertSecurityTeam('AI output contained execution fields');
      
      throw new AIAutonomyViolationError('AI cannot have execution capabilities');
    }
    
    // Verify output is read-only (frozen)
    return Object.freeze(output) as AIOutput;
  }
  
  private isAdvisoryOutput(output: unknown): output is AIOutput {
    return (
      typeof output === 'object' &&
      output !== null &&
      'type' in output &&
      (output as any).type === 'ADVISORY'
    );
  }
}

// Middleware that blocks any AI-initiated execution
class AIExecutionBlocker {
  block(req: Request, res: Response, next: NextFunction): void {
    // Check if request originated from AI service
    if (req.headers['x-source-service'] === 'ai-core') {
      // AI service cannot call execution endpoints
      if (this.isExecutionEndpoint(req.path)) {
        this.securityLogger.critical({
          event: 'AI_EXECUTION_BLOCKED',
          path: req.path,
          source: 'ai-core',
        });
        
        return res.status(403).json({
          error: 'AI service cannot call execution endpoints',
          code: 'AI_AUTONOMY_BLOCKED',
        });
      }
    }
    
    next();
  }
}
```

### 3.3 Audit Trail Requirements

```typescript
// Every AI output is logged immutably
interface AIAuditEntry {
  id: string;
  timestamp: Date;
  
  // What AI produced
  input: object;
  output: AIOutput;
  
  // Proof it was advisory only
  outputType: 'ADVISORY';  // Always this value
  executionAttempted: false;  // Always false
  
  // Hash chain for immutability
  previousHash: string;
  currentHash: string;
}

// Audit log is append-only (no updates, no deletes)
class AIAuditLogger {
  async log(entry: Omit<AIAuditEntry, 'id' | 'previousHash' | 'currentHash'>): Promise<void> {
    const previousEntry = await this.getLastEntry();
    
    const auditEntry: AIAuditEntry = {
      ...entry,
      id: uuid(),
      outputType: 'ADVISORY',
      executionAttempted: false,
      previousHash: previousEntry?.currentHash || 'GENESIS',
      currentHash: '', // Computed below
    };
    
    // Compute hash of entire entry
    auditEntry.currentHash = this.computeHash(auditEntry);
    
    // Insert into append-only table
    await this.db.insert('ai_audit_log', auditEntry);
    
    // Verify chain integrity
    await this.verifyChainIntegrity();
  }
  
  // Periodic integrity check
  async verifyChainIntegrity(): Promise<boolean> {
    const entries = await this.db.query('SELECT * FROM ai_audit_log ORDER BY timestamp');
    
    for (let i = 1; i < entries.length; i++) {
      const expected = entries[i - 1].currentHash;
      const actual = entries[i].previousHash;
      
      if (expected !== actual) {
        this.securityLogger.critical({
          event: 'AI_AUDIT_CHAIN_BROKEN',
          index: i,
          expected,
          actual,
        });
        
        throw new AuditIntegrityError('AI audit chain integrity violated');
      }
    }
    
    return true;
  }
}
```


### 3.4 Kill Switch Hierarchy

```typescript
// Multiple independent kill switches - any one stops AI
interface KillSwitchHierarchy {
  // Level 0: Global emergency (stops everything)
  EMERGENCY_DISABLE_ALL: boolean;
  
  // Level 1: AI-specific (stops all AI features)
  AI_CORE_ENABLED: boolean;
  
  // Level 2: Feature-specific (granular control)
  AI_INTENT_CLASSIFICATION: boolean;
  AI_TRUST_SCORING: boolean;
  AI_RISK_ASSESSMENT: boolean;
  AI_DECISION_RECOMMENDATIONS: boolean;
  
  // Level 3: Corridor-specific (per-market control)
  CORRIDOR_AI_ADVISORY: boolean;
}

// Kill switch check runs BEFORE every AI operation
class KillSwitchGuard {
  async checkAllSwitches(): Promise<void> {
    const flags = await this.loadFlags();
    
    // Level 0: Emergency
    if (flags.EMERGENCY_DISABLE_ALL) {
      throw new KillSwitchActiveError('EMERGENCY_DISABLE_ALL is active');
    }
    
    // Level 1: AI master switch
    if (!flags.AI_CORE_ENABLED) {
      throw new KillSwitchActiveError('AI_CORE_ENABLED is false');
    }
    
    // Any kill switch activation is logged
    this.auditLogger.log({
      event: 'KILL_SWITCH_CHECK_PASSED',
      flags,
      timestamp: new Date(),
    });
  }
}

// Kill switch activation is instant and irreversible without manual intervention
class KillSwitchActivator {
  async activate(switchName: string, reason: string, activatedBy: string): Promise<void> {
    // 1. Set flag immediately (no delay)
    await this.flagStore.set(switchName, true);
    
    // 2. Broadcast to all services (pub/sub)
    await this.broadcast({
      type: 'KILL_SWITCH_ACTIVATED',
      switch: switchName,
      reason,
      activatedBy,
      timestamp: new Date(),
    });
    
    // 3. Log to immutable audit
    await this.auditLog.write({
      action: 'KILL_SWITCH_ACTIVATED',
      switch: switchName,
      reason,
      activatedBy,
      timestamp: new Date(),
    });
    
    // 4. Alert ops team
    await this.alertOps({
      type: 'KILL_SWITCH',
      switch: switchName,
      reason,
      severity: 'CRITICAL',
    });
    
    // 5. Deactivation requires manual approval
    // (cannot be automated)
  }
}
```

### 3.5 Continuous Monitoring

```typescript
// Automated monitoring for autonomy violations
interface AutonomyMonitor {
  // Check 1: AI service should never make write queries
  checkDatabaseWrites(): Promise<void>;
  
  // Check 2: AI service should never call execution endpoints
  checkExecutionCalls(): Promise<void>;
  
  // Check 3: AI outputs should always be advisory type
  checkOutputTypes(): Promise<void>;
  
  // Check 4: No confirmation tokens should originate from AI
  checkTokenOrigins(): Promise<void>;
}

class AutonomyViolationDetector {
  // Runs every minute
  @Cron('* * * * *')
  async detectViolations(): Promise<void> {
    // Check database query logs
    const writeQueries = await this.db.query(`
      SELECT * FROM pg_stat_statements
      WHERE userid = (SELECT usesysid FROM pg_user WHERE usename = 'ai_service_user')
      AND query NOT LIKE 'SELECT%'
    `);
    
    if (writeQueries.length > 0) {
      await this.raiseViolation('AI_DATABASE_WRITE_ATTEMPT', writeQueries);
    }
    
    // Check API call logs
    const executionCalls = await this.apiLogs.query({
      source: 'ai-core',
      path: { $regex: /\/(execute|approve|transfer|payment)/ },
    });
    
    if (executionCalls.length > 0) {
      await this.raiseViolation('AI_EXECUTION_CALL_ATTEMPT', executionCalls);
    }
    
    // Check AI output types
    const nonAdvisoryOutputs = await this.aiAuditLog.query({
      outputType: { $ne: 'ADVISORY' },
    });
    
    if (nonAdvisoryOutputs.length > 0) {
      await this.raiseViolation('AI_NON_ADVISORY_OUTPUT', nonAdvisoryOutputs);
    }
  }
  
  private async raiseViolation(type: string, evidence: any): Promise<void> {
    // 1. Activate kill switch immediately
    await this.killSwitch.activate('AI_CORE_ENABLED', `Violation detected: ${type}`, 'SYSTEM');
    
    // 2. Log to security audit
    await this.securityAudit.critical({
      event: 'AI_AUTONOMY_VIOLATION',
      type,
      evidence,
      timestamp: new Date(),
    });
    
    // 3. Page security team
    await this.pagerDuty.alert({
      severity: 'CRITICAL',
      title: `AI Autonomy Violation: ${type}`,
      details: evidence,
    });
  }
}
```

---

## Part 4: Summary of Boundaries

### What AI CAN Do (Advisory Only)

| Capability | Description | Output Type |
|------------|-------------|-------------|
| Classify Intent | Determine user's likely goal | `ADVISORY` |
| Score Trust | Calculate trust score | `ADVISORY` |
| Assess Risk | Evaluate transaction risk | `ADVISORY` |
| Recommend | Suggest actions to user | `ADVISORY` |
| Explain | Provide reasoning for recommendations | `ADVISORY` |

### What AI CANNOT Do (Architecturally Impossible)

| Action | Why Impossible |
|--------|----------------|
| Execute payments | No access to payment credentials |
| Approve transactions | Cannot generate confirmation tokens |
| Modify user data | Database user is READ-ONLY |
| Release escrow | No access to escrow signing keys |
| Call PSPs | Network policy blocks outbound |
| Bypass human confirmation | Token requires private key AI doesn't have |
| Auto-resolve disputes | No write access to dispute tables |
| Change trust scores | Can only read, not write |

### Defense in Depth Layers

```
Layer 1: Type System          → AI outputs typed as ADVISORY only
Layer 2: Function Signatures  → No execution methods exist
Layer 3: Database Permissions → READ-ONLY user
Layer 4: Network Policies     → Cannot reach execution services
Layer 5: Cryptographic        → Cannot forge confirmation tokens
Layer 6: Code Review          → Security team reviews all AI changes
Layer 7: Runtime Validation   → Blocks any execution attempts
Layer 8: Audit Trail          → Immutable log of all AI actions
Layer 9: Kill Switches        → Instant disable at multiple levels
Layer 10: Continuous Monitor  → Automated violation detection
```

---

## Verification Checklist

Before any deployment, verify:

```
□ AI service database user is READ-ONLY
□ AI service has no payment credentials in environment
□ Network policy blocks AI → execution service
□ AI service cannot reach external payment providers
□ Confirmation token private key is NOT in AI service
□ All AI outputs are typed as ADVISORY
□ No execution methods exist in AI service code
□ Kill switches are functional and tested
□ Audit logging is enabled and immutable
□ Monitoring alerts are configured
□ Security team has reviewed changes
```

---

*Document Version: 1.0*
*Last Updated: December 2025*
*Classification: SECURITY-CRITICAL*
*Review Required: Security Team, AI Safety Team*

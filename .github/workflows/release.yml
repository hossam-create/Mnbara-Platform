name: Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
      skip_tests:
        description: 'Skip tests (use with caution)'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  EKS_CLUSTER_NAME: mnbara-cluster

jobs:
  # ============================================
  # Validate Release
  # ============================================
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Release version: ${VERSION}"

      - name: Validate version format
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "Invalid version format: $VERSION"
            echo "Expected format: v1.0.0 or v1.0.0-beta"
            exit 1
          fi

  # ============================================
  # Run Tests
  # ============================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Run backend tests
        run: |
          for service in backend/services/*/; do
            if [ -f "$service/package.json" ]; then
              echo "Testing $service"
              cd "$service"
              npm ci
              npm test --if-present || true
              cd -
            fi
          done

      - name: Run frontend tests
        run: |
          cd frontend/web
          npm ci
          npm test -- --run --passWithNoTests

  # ============================================
  # Build Release Images
  # ============================================
  build:
    name: Build Release Images
    runs-on: ubuntu-latest
    needs: [validate, test]
    if: always() && needs.validate.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        service:
          - api-gateway
          - auth-service
          - auction-service
          - payment-service
          - listing-service
          - crowdship-service
          - notification-service
          - recommendation-service
          - rewards-service
          - orders-service
          - trips-service
          - matching-service
          - admin-service
          - web-frontend
          - admin-dashboard
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine build context
        id: context
        run: |
          SERVICE="${{ matrix.service }}"
          if [ "$SERVICE" == "web-frontend" ]; then
            echo "path=frontend/web" >> $GITHUB_OUTPUT
          elif [ "$SERVICE" == "admin-dashboard" ]; then
            echo "path=frontend/admin-dashboard" >> $GITHUB_OUTPUT
          else
            echo "path=backend/services/$SERVICE" >> $GITHUB_OUTPUT
          fi

      - name: Check if Dockerfile exists
        id: check-dockerfile
        run: |
          if [ -f "${{ steps.context.outputs.path }}/Dockerfile" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        if: steps.check-dockerfile.outputs.exists == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: steps.check-dockerfile.outputs.exists == 'true'
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        if: steps.check-dockerfile.outputs.exists == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        if: steps.check-dockerfile.outputs.exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.context.outputs.path }}
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/mnbara/${{ matrix.service }}:${{ needs.validate.outputs.version }}
            ${{ env.ECR_REGISTRY }}/mnbara/${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            VERSION=${{ needs.validate.outputs.version }}

  # ============================================
  # Deploy to Production
  # ============================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, build]
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Setup Helm
        uses: azure/setup-helm@v3

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }}-production --region ${{ env.AWS_REGION }}

      - name: Update Helm dependencies
        working-directory: infrastructure/k8s/mnbara
        run: helm dependency update

      - name: Deploy with Helm
        working-directory: infrastructure/k8s/mnbara
        run: |
          helm upgrade --install mnbara . \
            -f values-prod.yaml \
            --namespace mnbara-production \
            --create-namespace \
            --set image.tag=${{ needs.validate.outputs.version }} \
            --set global.environment=production \
            --wait \
            --timeout 15m

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/api-gateway -n mnbara-production --timeout=5m
          kubectl rollout status deployment/auth-service -n mnbara-production --timeout=5m
          kubectl rollout status deployment/auction-service -n mnbara-production --timeout=5m
          kubectl rollout status deployment/payment-service -n mnbara-production --timeout=5m

  # ============================================
  # Create GitHub Release
  # ============================================
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate, deploy-production]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          if [ -n "$PREV_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" $PREV_TAG..HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" -20)
          fi
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.validate.outputs.version }}
          name: Release ${{ needs.validate.outputs.version }}
          body: |
            ## What's Changed
            
            ${{ steps.changelog.outputs.changelog }}
            
            ## Deployment
            
            This release has been automatically deployed to production.
            
            ## Docker Images
            
            All service images are available at:
            - `${{ env.ECR_REGISTRY }}/mnbara/<service>:${{ needs.validate.outputs.version }}`
          draft: false
          prerelease: ${{ contains(needs.validate.outputs.version, '-') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ============================================
  # Notify Release
  # ============================================
  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [validate, deploy-production, create-release]
    if: always()
    steps:
      - name: Send Slack notification
        if: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "${{ needs.deploy-production.result == 'success' && 'üöÄ' || '‚ùå' }} Release ${{ needs.validate.outputs.version }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ needs.deploy-production.result == 'success' && 'üöÄ Release Successful' || '‚ùå Release Failed' }}\n*Version:* ${{ needs.validate.outputs.version }}\n*Environment:* Production\n*Actor:* ${{ github.actor }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

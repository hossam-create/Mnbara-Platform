/**
 * Webhook Event Service
 * Handles logging and processing of webhook events from payment providers
 */

import { PrismaClient } from '@prisma/client';
import { PaymentRecordService, PaymentProvider } from './payment-record.service';
import { EventPublisher } from './event-publisher.service';

const prisma = new PrismaClient();

// Type definition for WebhookEvent (will be generated by Prisma after migration)
export interface WebhookEvent {
  id: number;
  provider: PaymentProvider;
  eventId: string;
  eventType: string;
  paymentId: number | null;
  externalPaymentId: string | null;
  payload: any;
  headers: any;
  processed: boolean;
  processedAt: Date | null;
  processingError: string | null;
  retryCount: number;
  receivedAt: Date;
}

export interface WebhookEventData {
  provider: PaymentProvider;
  eventId: string;
  eventType: string;
  externalPaymentId?: string;
  payload: any;
  headers?: any;
}

export interface ProcessedWebhookResult {
  success: boolean;
  eventId: string;
  paymentId?: number;
  action?: string;
  error?: string;
}

export class WebhookEventService {
  /**
   * Log a webhook event (idempotent - won't duplicate)
   */
  static async logEvent(data: WebhookEventData): Promise<WebhookEvent | null> {
    try {
      // Check if event already exists (idempotency)
      const existing = await prisma.webhookEvent.findUnique({
        where: {
          provider_eventId: {
            provider: data.provider,
            eventId: data.eventId
          }
        }
      });

      if (existing) {
        console.log(`Webhook event ${data.eventId} already logged, skipping`);
        return existing;
      }

      // Find related payment if externalPaymentId provided
      let paymentId: number | undefined;
      if (data.externalPaymentId) {
        const payment = await PaymentRecordService.findByExternalId(
          data.provider,
          data.externalPaymentId
        );
        paymentId = payment?.id;
      }

      return await prisma.webhookEvent.create({
        data: {
          provider: data.provider,
          eventId: data.eventId,
          eventType: data.eventType,
          externalPaymentId: data.externalPaymentId,
          paymentId,
          payload: data.payload,
          headers: data.headers
        }
      });
    } catch (error: any) {
      // Handle unique constraint violation (race condition)
      if (error.code === 'P2002') {
        console.log(`Webhook event ${data.eventId} already exists (race condition)`);
        return null;
      }
      throw error;
    }
  }

  /**
   * Mark event as processed
   */
  static async markProcessed(eventId: number, error?: string): Promise<void> {
    await prisma.webhookEvent.update({
      where: { id: eventId },
      data: {
        processed: true,
        processedAt: new Date(),
        processingError: error,
        retryCount: error ? { increment: 1 } : undefined
      }
    });
  }

  /**
   * Process Stripe webhook event
   */
  static async processStripeEvent(event: any): Promise<ProcessedWebhookResult> {
    const eventId = event.id;
    const eventType = event.type;
    const data = event.data.object;

    // Log the event
    const webhookEvent = await this.logEvent({
      provider: 'STRIPE',
      eventId,
      eventType,
      externalPaymentId: data.id,
      payload: event
    });

    if (!webhookEvent) {
      return { success: true, eventId, action: 'duplicate_skipped' };
    }

    try {
      const result: ProcessedWebhookResult = { success: true, eventId };

      switch (eventType) {
        case 'payment_intent.succeeded':
          await PaymentRecordService.markSucceeded(
            'STRIPE',
            data.id,
            data.amount_received / 100
          );
          
          // PAY-001: Create escrow after payment succeeds (webhook integration)
          if (data.metadata?.orderId) {
            try {
              const orderId = parseInt(data.metadata.orderId);
              const order = await prisma.order.findUnique({
                where: { id: orderId },
                include: { buyer: true, traveler: true },
              });

              if (order) {
                // Check if escrow already exists
                const existingEscrow = await prisma.escrow.findUnique({
                  where: { orderId },
                });

                if (!existingEscrow) {
                  // Determine order type from metadata or default to BUY_NOW
                  const orderType = data.metadata?.orderType === 'AUCTION' ? 'AUCTION' : 'BUY_NOW';
                  
                  // Create escrow only after payment succeeds
                  const escrow = await prisma.escrow.create({
                    data: {
                      orderId,
                      buyerId: order.buyerId || 0,
                      sellerId: order.travelerId || 0,
                      travelerId: order.travelerId || null,
                      amount: order.totalAmount,
                      currency: order.currency,
                      stripePaymentId: data.id,
                      orderType,
                      status: 'HELD',
                      heldAt: new Date(),
                      autoReleaseAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
                    },
                  });

                  // Log escrow creation
                  await prisma.escrowActionLog.create({
                    data: {
                      escrowId: escrow.id,
                      action: 'CREATED',
                      performedBy: order.buyerId || null,
                      performedByRole: 'system',
                      metadata: {
                        source: 'webhook',
                        paymentIntentId: data.id,
                        orderType,
                      },
                    },
                  });

                  console.log(`[Webhook] Escrow created for order ${orderId} via payment success webhook`);
                }
              }
            } catch (escrowError: any) {
              console.error('[Webhook] Failed to create escrow on payment success:', escrowError);
              // Don't fail webhook processing if escrow creation fails
            }
          }
          
          await EventPublisher.publishPaymentSucceeded({
            provider: 'stripe',
            paymentId: data.id,
            amount: data.amount_received / 100,
            currency: data.currency,
            orderId: data.metadata?.orderId,
            userId: data.metadata?.userId
          });
          result.action = 'payment_succeeded';
          break;

        case 'payment_intent.payment_failed':
          await PaymentRecordService.markFailed(
            'STRIPE',
            data.id,
            data.last_payment_error?.message,
            data.last_payment_error?.code
          );
          await EventPublisher.publishPaymentFailed({
            provider: 'stripe',
            paymentId: data.id,
            error: data.last_payment_error?.message,
            orderId: data.metadata?.orderId,
            userId: data.metadata?.userId
          });
          result.action = 'payment_failed';
          break;

        case 'payment_intent.canceled':
          await PaymentRecordService.updatePaymentStatus(
            'STRIPE',
            data.id,
            { status: 'CANCELED', externalStatus: 'canceled' }
          );
          result.action = 'payment_canceled';
          break;

        case 'charge.refunded':
          const refundAmount = data.amount_refunded / 100;
          const isPartial = data.amount_refunded < data.amount;
          await PaymentRecordService.markRefunded(
            'STRIPE',
            data.payment_intent,
            refundAmount,
            isPartial
          );
          await EventPublisher.publishPaymentRefunded({
            provider: 'stripe',
            paymentId: data.payment_intent,
            amount: refundAmount,
            isPartial,
            orderId: data.metadata?.orderId
          });
          result.action = 'payment_refunded';
          break;

        case 'charge.dispute.created':
          await PaymentRecordService.markDisputed(
            'STRIPE',
            data.payment_intent,
            { disputeId: data.id, reason: data.reason, amount: data.amount / 100 }
          );
          await EventPublisher.publishDisputeCreated({
            provider: 'stripe',
            paymentId: data.payment_intent,
            disputeId: data.id,
            reason: data.reason,
            amount: data.amount / 100
          });
          result.action = 'dispute_created';
          break;

        default:
          result.action = 'unhandled_event';
      }

      await this.markProcessed(webhookEvent.id);
      return result;

    } catch (error: any) {
      await this.markProcessed(webhookEvent.id, error.message);
      return { success: false, eventId, error: error.message };
    }
  }

  /**
   * Process PayPal webhook event
   */
  static async processPayPalEvent(event: any): Promise<ProcessedWebhookResult> {
    const eventId = event.id;
    const eventType = event.event_type;
    const resource = event.resource;

    // Log the event
    const webhookEvent = await this.logEvent({
      provider: 'PAYPAL',
      eventId,
      eventType,
      externalPaymentId: resource.id,
      payload: event
    });

    if (!webhookEvent) {
      return { success: true, eventId, action: 'duplicate_skipped' };
    }

    try {
      const result: ProcessedWebhookResult = { success: true, eventId };

      switch (eventType) {
        case 'PAYMENT.CAPTURE.COMPLETED':
          const captureAmount = parseFloat(resource.amount?.value || '0');
          await PaymentRecordService.markSucceeded(
            'PAYPAL',
            resource.supplementary_data?.related_ids?.order_id || resource.id,
            captureAmount
          );
          await EventPublisher.publishPaymentSucceeded({
            provider: 'paypal',
            paymentId: resource.id,
            amount: captureAmount,
            currency: resource.amount?.currency_code,
            orderId: resource.custom_id
          });
          result.action = 'payment_captured';
          break;

        case 'PAYMENT.CAPTURE.DENIED':
          await PaymentRecordService.markFailed(
            'PAYPAL',
            resource.supplementary_data?.related_ids?.order_id || resource.id,
            'Payment capture denied'
          );
          await EventPublisher.publishPaymentFailed({
            provider: 'paypal',
            paymentId: resource.id,
            error: 'Payment capture denied'
          });
          result.action = 'payment_denied';
          break;

        case 'PAYMENT.CAPTURE.REFUNDED':
          const paypalRefundAmount = parseFloat(resource.amount?.value || '0');
          await PaymentRecordService.markRefunded(
            'PAYPAL',
            resource.supplementary_data?.related_ids?.order_id || resource.id,
            paypalRefundAmount
          );
          await EventPublisher.publishPaymentRefunded({
            provider: 'paypal',
            paymentId: resource.id,
            amount: paypalRefundAmount
          });
          result.action = 'payment_refunded';
          break;

        case 'CHECKOUT.ORDER.APPROVED':
          await PaymentRecordService.updatePaymentStatus(
            'PAYPAL',
            resource.id,
            { status: 'PROCESSING', externalStatus: 'APPROVED' }
          );
          result.action = 'order_approved';
          break;

        default:
          result.action = 'unhandled_event';
      }

      await this.markProcessed(webhookEvent.id);
      return result;

    } catch (error: any) {
      await this.markProcessed(webhookEvent.id, error.message);
      return { success: false, eventId, error: error.message };
    }
  }

  /**
   * Process Paymob webhook event
   */
  static async processPaymobEvent(
    transactionData: any,
    hmacValid: boolean
  ): Promise<ProcessedWebhookResult> {
    const obj = transactionData.obj;
    const eventId = `paymob_${obj.id}_${obj.created_at}`;
    const eventType = obj.success ? 'transaction.success' : 
                      obj.pending ? 'transaction.pending' : 'transaction.failed';

    // Log the event
    const webhookEvent = await this.logEvent({
      provider: 'PAYMOB',
      eventId,
      eventType,
      externalPaymentId: obj.order?.id?.toString() || obj.id.toString(),
      payload: transactionData
    });

    if (!webhookEvent) {
      return { success: true, eventId, action: 'duplicate_skipped' };
    }

    if (!hmacValid) {
      await this.markProcessed(webhookEvent.id, 'Invalid HMAC signature');
      return { success: false, eventId, error: 'Invalid HMAC signature' };
    }

    try {
      const result: ProcessedWebhookResult = { success: true, eventId };
      const orderId = obj.order?.id?.toString() || obj.id.toString();
      const amount = obj.amount_cents / 100;

      if (obj.success) {
        await PaymentRecordService.markSucceeded(
          'PAYMOB',
          orderId,
          amount
        );
        await EventPublisher.publishPaymentSucceeded({
          provider: 'paymob',
          paymentId: obj.id.toString(),
          amount,
          currency: obj.currency,
          orderId: obj.order?.merchant_order_id
        });
        result.action = 'payment_succeeded';
      } else if (!obj.pending) {
        await PaymentRecordService.markFailed(
          'PAYMOB',
          orderId,
          obj.data?.message || 'Payment failed'
        );
        await EventPublisher.publishPaymentFailed({
          provider: 'paymob',
          paymentId: obj.id.toString(),
          error: obj.data?.message
        });
        result.action = 'payment_failed';
      } else {
        result.action = 'payment_pending';
      }

      await this.markProcessed(webhookEvent.id);
      return result;

    } catch (error: any) {
      await this.markProcessed(webhookEvent.id, error.message);
      return { success: false, eventId, error: error.message };
    }
  }

  /**
   * Get unprocessed events for retry
   */
  static async getUnprocessedEvents(limit: number = 100): Promise<WebhookEvent[]> {
    return await prisma.webhookEvent.findMany({
      where: {
        processed: false,
        retryCount: { lt: 3 }
      },
      orderBy: { receivedAt: 'asc' },
      take: limit
    });
  }

  /**
   * Get events by payment ID
   */
  static async getEventsByPayment(paymentId: number): Promise<WebhookEvent[]> {
    return await prisma.webhookEvent.findMany({
      where: { paymentId },
      orderBy: { receivedAt: 'desc' }
    });
  }
}

export default WebhookEventService;

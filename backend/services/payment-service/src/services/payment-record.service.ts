/**
 * Payment Record Service
 * Manages payment records in the database for tracking external provider transactions
 */

import { PrismaClient } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';

const prisma = new PrismaClient();

// Type definitions (will be generated by Prisma after migration)
export type PaymentProvider = 'STRIPE' | 'PAYPAL' | 'PAYMOB' | 'WALLET' | 'BLOCKCHAIN';
export type PaymentStatus = 'PENDING' | 'PROCESSING' | 'REQUIRES_ACTION' | 'SUCCEEDED' | 'FAILED' | 'CANCELED' | 'REFUNDED' | 'PARTIALLY_REFUNDED' | 'DISPUTED';
export type PaymentMethodType = 'CARD' | 'PAYPAL' | 'MOBILE_WALLET' | 'BANK_TRANSFER' | 'CRYPTO' | 'WALLET_BALANCE';

export interface Payment {
  id: number;
  provider: PaymentProvider;
  externalId: string;
  externalStatus: string | null;
  orderId: number | null;
  userId: number;
  escrowId: number | null;
  amount: Decimal;
  currency: string;
  fee: Decimal | null;
  netAmount: Decimal | null;
  status: PaymentStatus;
  method: PaymentMethodType | null;
  methodDetails: any;
  captureMethod: string | null;
  capturedAt: Date | null;
  capturedAmount: Decimal | null;
  refundedAmount: Decimal | null;
  refundedAt: Date | null;
  description: string | null;
  metadata: any;
  errorMessage: string | null;
  errorCode: string | null;
  lastWebhookAt: Date | null;
  webhookCount: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreatePaymentRecordParams {
  provider: PaymentProvider;
  externalId: string;
  userId: number;
  amount: number;
  currency?: string;
  orderId?: number;
  escrowId?: number;
  method?: PaymentMethodType;
  methodDetails?: any;
  captureMethod?: string;
  description?: string;
  metadata?: any;
}

export interface UpdatePaymentStatusParams {
  status: PaymentStatus;
  externalStatus?: string;
  errorMessage?: string;
  errorCode?: string;
  capturedAt?: Date;
  capturedAmount?: number;
  fee?: number;
  netAmount?: number;
  methodDetails?: any;
  metadata?: any;
}

export class PaymentRecordService {
  /**
   * Create a new payment record
   */
  static async createPayment(params: CreatePaymentRecordParams): Promise<Payment> {
    const {
      provider,
      externalId,
      userId,
      amount,
      currency = 'USD',
      orderId,
      escrowId,
      method,
      methodDetails,
      captureMethod,
      description,
      metadata
    } = params;

    return await prisma.payment.create({
      data: {
        provider,
        externalId,
        userId,
        amount: new Decimal(amount),
        currency: currency.toUpperCase(),
        orderId,
        escrowId,
        method,
        methodDetails,
        captureMethod,
        description,
        metadata,
        status: 'PENDING' as PaymentStatus
      }
    });
  }

  /**
   * Find payment by provider and external ID
   */
  static async findByExternalId(provider: PaymentProvider, externalId: string): Promise<Payment | null> {
    return await prisma.payment.findUnique({
      where: {
        provider_externalId: { provider, externalId }
      }
    });
  }

  /**
   * Find payment by ID
   */
  static async findById(id: number): Promise<Payment | null> {
    return await prisma.payment.findUnique({
      where: { id }
    });
  }

  /**
   * Update payment status from webhook
   */
  static async updatePaymentStatus(
    provider: PaymentProvider,
    externalId: string,
    params: UpdatePaymentStatusParams
  ): Promise<Payment | null> {
    const payment = await this.findByExternalId(provider, externalId);
    if (!payment) return null;

    const updateData: any = {
      status: params.status,
      lastWebhookAt: new Date(),
      webhookCount: { increment: 1 }
    };

    if (params.externalStatus) updateData.externalStatus = params.externalStatus;
    if (params.errorMessage) updateData.errorMessage = params.errorMessage;
    if (params.errorCode) updateData.errorCode = params.errorCode;
    if (params.capturedAt) updateData.capturedAt = params.capturedAt;
    if (params.capturedAmount !== undefined) updateData.capturedAmount = new Decimal(params.capturedAmount);
    if (params.fee !== undefined) updateData.fee = new Decimal(params.fee);
    if (params.netAmount !== undefined) updateData.netAmount = new Decimal(params.netAmount);
    if (params.methodDetails) updateData.methodDetails = params.methodDetails;
    if (params.metadata) {
      updateData.metadata = {
        ...(payment.metadata as object || {}),
        ...params.metadata
      };
    }

    return await prisma.payment.update({
      where: { id: payment.id },
      data: updateData
    });
  }

  /**
   * Mark payment as succeeded
   */
  static async markSucceeded(
    provider: PaymentProvider,
    externalId: string,
    capturedAmount?: number,
    fee?: number
  ): Promise<Payment | null> {
    return await this.updatePaymentStatus(provider, externalId, {
      status: 'SUCCEEDED',
      capturedAt: new Date(),
      capturedAmount,
      fee,
      netAmount: capturedAmount && fee ? capturedAmount - fee : undefined
    });
  }

  /**
   * Mark payment as failed
   */
  static async markFailed(
    provider: PaymentProvider,
    externalId: string,
    errorMessage?: string,
    errorCode?: string
  ): Promise<Payment | null> {
    return await this.updatePaymentStatus(provider, externalId, {
      status: 'FAILED',
      errorMessage,
      errorCode
    });
  }

  /**
   * Mark payment as refunded
   */
  static async markRefunded(
    provider: PaymentProvider,
    externalId: string,
    refundedAmount: number,
    isPartial: boolean = false
  ): Promise<Payment | null> {
    const payment = await this.findByExternalId(provider, externalId);
    if (!payment) return null;

    const totalRefunded = Number(payment.refundedAmount || 0) + refundedAmount;
    const status: PaymentStatus = isPartial ? 'PARTIALLY_REFUNDED' : 'REFUNDED';

    return await prisma.payment.update({
      where: { id: payment.id },
      data: {
        status,
        refundedAmount: new Decimal(totalRefunded),
        refundedAt: new Date(),
        lastWebhookAt: new Date(),
        webhookCount: { increment: 1 }
      }
    });
  }

  /**
   * Mark payment as disputed
   */
  static async markDisputed(
    provider: PaymentProvider,
    externalId: string,
    disputeDetails?: any
  ): Promise<Payment | null> {
    return await this.updatePaymentStatus(provider, externalId, {
      status: 'DISPUTED',
      metadata: { disputeDetails, disputedAt: new Date().toISOString() }
    });
  }

  /**
   * Get payments by user
   */
  static async getPaymentsByUser(userId: number, limit: number = 50): Promise<Payment[]> {
    return await prisma.payment.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: limit
    });
  }

  /**
   * Get payments by order
   */
  static async getPaymentsByOrder(orderId: number): Promise<Payment[]> {
    return await prisma.payment.findMany({
      where: { orderId },
      orderBy: { createdAt: 'desc' }
    });
  }

  /**
   * Get pending payments older than specified minutes (for cleanup/retry)
   */
  static async getPendingPayments(olderThanMinutes: number = 30): Promise<Payment[]> {
    const cutoffTime = new Date(Date.now() - olderThanMinutes * 60 * 1000);
    
    return await prisma.payment.findMany({
      where: {
        status: 'PENDING' as PaymentStatus,
        createdAt: { lt: cutoffTime }
      },
      orderBy: { createdAt: 'asc' }
    });
  }
}

export default PaymentRecordService;

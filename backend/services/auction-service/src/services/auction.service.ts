import { PrismaClient, Prisma } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';

const prisma = new PrismaClient();

// Enum definitions (will be generated by Prisma after migration)
enum ListingStatus {
  DRAFT = 'DRAFT',
  SCHEDULED = 'SCHEDULED',
  ACTIVE = 'ACTIVE',
  ENDED = 'ENDED',        // AUC-001: Clear auction end state
  SOLD = 'SOLD',
  EXPIRED = 'EXPIRED',
  CANCELLED = 'CANCELLED',
  DELETED = 'DELETED'
}

enum BidStatus {
  ACTIVE = 'ACTIVE',
  OUTBID = 'OUTBID',
  WINNING = 'WINNING',
  WON = 'WON',
  CANCELLED = 'CANCELLED'
}

// Type for Prisma transaction client
type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use' | '$extends'>;

// Configuration for auto-extend feature
export interface AutoExtendConfig {
  enabled: boolean;
  thresholdMs: number;    // Time remaining threshold to trigger extension
  durationMs: number;     // How long to extend
  maxExtensions: number;  // Maximum number of extensions allowed
}

export interface PlaceBidResult {
  bid: any;
  auction: any;
  wasExtended: boolean;
  extensionInfo?: {
    previousEndTime: Date;
    newEndTime: Date;
    extensionNumber: number;
  };
  outbidUsers: number[];
}

export interface CreateAuctionParams {
  title: string;
  description: string;
  sellerId: number;
  startingBid: number;
  reservePrice?: number;
  buyNowPrice?: number;
  auctionEndsAt: Date;
  auctionStartsAt?: Date;
  currency?: string;
  autoExtendConfig?: Partial<AutoExtendConfig>;
  minBidIncrement?: number;
}

export class AuctionService {
  // Default auto-extend configuration
  private static readonly DEFAULT_AUTO_EXTEND_CONFIG: AutoExtendConfig = {
    enabled: true,
    thresholdMs: 2 * 60 * 1000,  // 2 minutes
    durationMs: 2 * 60 * 1000,   // 2 minutes
    maxExtensions: 10
  };

  /**
   * Create a new auction listing
   */
  async createAuction(data: CreateAuctionParams) {
    const autoExtend = {
      ...AuctionService.DEFAULT_AUTO_EXTEND_CONFIG,
      ...data.autoExtendConfig
    };

    return prisma.listing.create({
      data: {
        title: data.title,
        description: data.description,
        sellerId: data.sellerId,
        price: data.startingBid,
        currency: data.currency || 'USD',
        isAuction: true,
        startingBid: data.startingBid,
        reservePrice: data.reservePrice,
        buyNowPrice: data.buyNowPrice,
        currentBid: data.startingBid,
        auctionEndsAt: data.auctionEndsAt,
        auctionStartsAt: data.auctionStartsAt || new Date(),
        originalEndTime: data.auctionEndsAt,
        autoExtendEnabled: autoExtend.enabled,
        autoExtendThresholdMs: autoExtend.thresholdMs,
        autoExtendDurationMs: autoExtend.durationMs,
        maxExtensions: autoExtend.maxExtensions,
        extensionCount: 0,
        minBidIncrement: data.minBidIncrement || 1.00,
        status: ListingStatus.ACTIVE,
      },
    });
  }

  /**
   * Get auction details with bids
   * AUC-001: Returns current highest bid and bidder information
   */
  async getAuction(id: number) {
    const auction = await prisma.listing.findUnique({
      where: { id, isAuction: true },
      include: {
        seller: {
          select: { id: true, firstName: true, lastName: true },
        },
        bids: {
          orderBy: { amount: 'desc' },
          take: 10,
          include: {
            bidder: {
              select: { id: true, firstName: true, lastName: true },
            },
          },
        },
        auctionExtensions: {
          orderBy: { createdAt: 'desc' },
          take: 5,
        },
      },
    });

    if (!auction) return null;

    // AUC-001: Get current highest bidder (bid with WINNING status)
    const currentWinningBid = auction.bids.find(bid => bid.status === BidStatus.WINNING);
    const currentBidder = currentWinningBid ? {
      id: currentWinningBid.bidderId,
      ...currentWinningBid.bidder,
    } : null;

    return {
      ...auction,
      currentBidder, // AUC-001: Explicitly include current bidder
    };
  }


  /**
   * Get active auctions with optional filters
   */
  async getActiveAuctions(filters?: {
    categoryId?: number;
    minPrice?: number;
    maxPrice?: number;
    endingSoon?: boolean;
    limit?: number;
    offset?: number;
  }) {
    const where: any = {
      isAuction: true,
      status: ListingStatus.ACTIVE,
      auctionEndsAt: { gt: new Date() },
    };

    if (filters?.minPrice) {
      where.currentBid = { ...where.currentBid, gte: filters.minPrice };
    }
    if (filters?.maxPrice) {
      where.currentBid = { ...where.currentBid, lte: filters.maxPrice };
    }

    const orderBy: any = { auctionEndsAt: 'asc' };
    
    if (filters?.endingSoon) {
      // Auctions ending within 1 hour
      const oneHourFromNow = new Date(Date.now() + 60 * 60 * 1000);
      where.auctionEndsAt = { gt: new Date(), lt: oneHourFromNow };
    }

    return prisma.listing.findMany({
      where,
      orderBy,
      take: filters?.limit || 20,
      skip: filters?.offset || 0,
      include: {
        seller: {
          select: { id: true, firstName: true, lastName: true },
        },
        _count: {
          select: { bids: true },
        },
      },
    });
  }

  /**
   * Place a bid with auto-extend logic
   * This is the core method that handles bid placement and sniping prevention
   */
  async placeBid(
    listingId: number,
    bidderId: number,
    amount: number
  ): Promise<PlaceBidResult> {
    return await prisma.$transaction(async (tx: TransactionClient) => {
      // 1. Get auction with pessimistic lock
      const auction = await tx.listing.findUnique({
        where: { id: listingId },
        include: {
          bids: {
            where: { status: { in: [BidStatus.ACTIVE, BidStatus.WINNING] } },
            orderBy: { amount: 'desc' },
            take: 1,
          },
        },
      });

      if (!auction) {
        throw new Error('Auction not found');
      }
      if (!auction.isAuction) {
        throw new Error('Listing is not an auction');
      }
      
      // AUC-001: Bids must be rejected if the auction is not ACTIVE
      if (auction.status !== ListingStatus.ACTIVE) {
        throw new Error(
          `Auction is not active. Current status: ${auction.status}. Only ACTIVE auctions accept bids.`
        );
      }
      
      if (auction.sellerId === bidderId) {
        throw new Error('Sellers cannot bid on their own auctions');
      }

      const now = new Date();
      // AUC-001: Auction end must be deterministic based on end time
      if (auction.auctionEndsAt && now > auction.auctionEndsAt) {
        throw new Error('Auction has ended');
      }

      // AUC-001: Bids must be higher than the current highest bid
      // 2. Validate bid amount
      const currentBid = Number(auction.currentBid || auction.startingBid || 0);
      const minIncrement = Number(auction.minBidIncrement || 1);
      const minimumBid = currentBid + minIncrement;

      if (amount < minimumBid) {
        throw new Error(
          `Bid must be higher than the current highest bid. Minimum bid: ${minimumBid} (current: ${currentBid}, min increment: ${minIncrement})`
        );
      }

      // 3. Check for auto-extend (sniping prevention)
      let newEndsAt = auction.auctionEndsAt;
      let wasExtended = false;
      let extensionInfo: PlaceBidResult['extensionInfo'] | undefined;

      if (
        auction.autoExtendEnabled &&
        auction.auctionEndsAt &&
        auction.extensionCount < auction.maxExtensions
      ) {
        const timeRemaining = auction.auctionEndsAt.getTime() - now.getTime();

        if (timeRemaining > 0 && timeRemaining < auction.autoExtendThresholdMs) {
          // Trigger auto-extend
          const previousEndTime = auction.auctionEndsAt;
          newEndsAt = new Date(auction.auctionEndsAt.getTime() + auction.autoExtendDurationMs);
          wasExtended = true;

          extensionInfo = {
            previousEndTime,
            newEndTime: newEndsAt,
            extensionNumber: auction.extensionCount + 1,
          };

          console.log(
            `Auction ${listingId} auto-extended: ${previousEndTime.toISOString()} -> ${newEndsAt.toISOString()} (extension #${extensionInfo.extensionNumber})`
          );
        }
      }

      // 4. Mark previous winning bid as outbid
      const outbidUsers: number[] = [];
      if (auction.bids.length > 0) {
        const previousWinningBid = auction.bids[0];
        if (previousWinningBid.bidderId !== bidderId) {
          outbidUsers.push(previousWinningBid.bidderId);
        }

        await tx.bid.updateMany({
          where: {
            listingId,
            status: BidStatus.WINNING,
          },
          data: {
            status: BidStatus.OUTBID,
          },
        });
      }

      // 5. Create new bid
      const bid = await tx.bid.create({
        data: {
          listingId,
          bidderId,
          amount,
          triggeredExtension: wasExtended,
          status: BidStatus.WINNING,
        },
        include: {
          bidder: {
            select: { id: true, firstName: true, lastName: true },
          },
        },
      });

      // 6. Record extension if it occurred
      if (wasExtended && extensionInfo) {
        await tx.auctionExtension.create({
          data: {
            listingId,
            previousEndTime: extensionInfo.previousEndTime,
            newEndTime: extensionInfo.newEndTime,
            extensionMs: auction.autoExtendDurationMs,
            triggeredByBidId: bid.id,
            extensionNumber: extensionInfo.extensionNumber,
          },
        });
      }

      // AUC-001: Auction must track current highest bid and bidder
      // 7. Update auction with new bid and possibly new end time
      const updatedAuction = await tx.listing.update({
        where: { id: listingId },
        data: {
          currentBid: amount,  // Track current highest bid
          // Note: winnerId is set when auction ends, not during bidding
          // Current bidder is tracked via Bid with WINNING status
          auctionEndsAt: newEndsAt,
          extensionCount: wasExtended ? { increment: 1 } : undefined,
        },
      });

      return {
        bid,
        auction: updatedAuction,
        wasExtended,
        extensionInfo,
        outbidUsers,
      };
    }, {
      isolationLevel: 'Serializable' as any,
      timeout: 10000,
    });
  }


  /**
   * Setup or update proxy bid for automatic bidding
   */
  async setupProxyBid(listingId: number, bidderId: number, maxAmount: number) {
    return await prisma.$transaction(async (tx: TransactionClient) => {
      const auction = await tx.listing.findUnique({
        where: { id: listingId },
      });

      if (!auction || !auction.isAuction) {
        throw new Error('Auction not found');
      }
      if (auction.status !== ListingStatus.ACTIVE) {
        throw new Error('Auction is not active');
      }

      const currentBid = Number(auction.currentBid || auction.startingBid || 0);
      if (maxAmount <= currentBid) {
        throw new Error(`Max amount must be higher than current bid (${currentBid})`);
      }

      // Create or update proxy bid
      const proxyBid = await tx.proxyBid.upsert({
        where: {
          listingId_bidderId: { listingId, bidderId },
        },
        create: {
          listingId,
          bidderId,
          maxAmount,
          currentBid: currentBid,
          isActive: true,
        },
        update: {
          maxAmount,
          isActive: true,
        },
      });

      return proxyBid;
    });
  }

  /**
   * Process proxy bids after a new bid is placed
   * This should be called after placeBid to handle automatic outbidding
   */
  async processProxyBids(listingId: number, currentBidAmount: number, currentBidderId: number) {
    const auction = await prisma.listing.findUnique({
      where: { id: listingId },
    });

    if (!auction) return null;

    // Find active proxy bids that can outbid the current bid
    const proxyBids = await prisma.proxyBid.findMany({
      where: {
        listingId,
        isActive: true,
        bidderId: { not: currentBidderId },
        maxAmount: { gt: currentBidAmount },
      },
      orderBy: { maxAmount: 'desc' },
    });

    if (proxyBids.length === 0) return null;

    // Get the highest proxy bid
    const highestProxy = proxyBids[0];
    const minIncrement = Number(auction.minBidIncrement || 1);

    // Calculate the bid amount (just enough to outbid, or max if needed)
    let bidAmount = currentBidAmount + minIncrement;
    
    // If there are multiple proxy bids, bid up to the second highest + increment
    if (proxyBids.length > 1) {
      const secondHighest = Number(proxyBids[1].maxAmount);
      bidAmount = Math.min(Number(highestProxy.maxAmount), secondHighest + minIncrement);
    }

    // Ensure we don't exceed the max amount
    bidAmount = Math.min(bidAmount, Number(highestProxy.maxAmount));

    // Place the proxy bid
    const result = await this.placeBid(listingId, highestProxy.bidderId, bidAmount);

    // Update the proxy bid's current bid
    await prisma.proxyBid.update({
      where: { id: highestProxy.id },
      data: { currentBid: bidAmount },
    });

    return result;
  }

  /**
   * Get bids for an auction
   */
  async getBids(listingId: number, limit: number = 50) {
    return prisma.bid.findMany({
      where: { listingId },
      orderBy: { amount: 'desc' },
      take: limit,
      include: {
        bidder: {
          select: { id: true, firstName: true, lastName: true },
        },
      },
    });
  }

  /**
   * End an auction and determine the winner
   */
  async endAuction(listingId: number) {
    return await prisma.$transaction(async (tx: TransactionClient) => {
      const auction = await tx.listing.findUnique({
        where: { id: listingId },
        include: {
          bids: {
            where: { status: BidStatus.WINNING },
            orderBy: { amount: 'desc' },
            take: 1,
          },
        },
      });

      if (!auction) {
        throw new Error('Auction not found');
      }
      if (auction.status !== ListingStatus.ACTIVE) {
        throw new Error('Auction is not active');
      }

      const winningBid = auction.bids[0];
      const reserveMet = !auction.reservePrice || 
        (winningBid && Number(winningBid.amount) >= Number(auction.reservePrice));

      // AUC-001: Winning bid must be clearly identified when auction ends
      let newStatus: ListingStatus;
      let winnerId: number | null = null;
      let finalPrice: Decimal | null = null;

      if (winningBid && reserveMet) {
        // AUC-001: Clearly identify winner and winning bid
        winnerId = winningBid.bidderId;   // AUC-001: Clearly identify winner
        finalPrice = winningBid.amount;   // AUC-001: Clearly identify winning bid amount
        newStatus = ListingStatus.SOLD;   // Reserve met, auction sold

        // Update winning bid status
        await tx.bid.update({
          where: { id: winningBid.id },
          data: { status: BidStatus.WON },
        });
      } else {
        // AUC-001: Auction ended but no winner (reserve not met or no bids)
        newStatus = ListingStatus.ENDED;  // AUC-001: Clear end state (not sold)
      }

      // Deactivate all proxy bids
      await tx.proxyBid.updateMany({
        where: { listingId },
        data: { isActive: false },
      });

      // Update auction
      const updatedAuction = await tx.listing.update({
        where: { id: listingId },
        data: {
          status: newStatus,
          winnerId,
          finalPrice,
          isActive: false,
        },
      });

      return {
        auction: updatedAuction,
        winner: winningBid ? {
          userId: winningBid.bidderId,
          amount: winningBid.amount,
        } : null,
        reserveMet,
      };
    });
  }

  /**
   * Update auto-extend configuration for an auction
   */
  async updateAutoExtendConfig(listingId: number, config: Partial<AutoExtendConfig>) {
    return prisma.listing.update({
      where: { id: listingId },
      data: {
        autoExtendEnabled: config.enabled,
        autoExtendThresholdMs: config.thresholdMs,
        autoExtendDurationMs: config.durationMs,
        maxExtensions: config.maxExtensions,
      },
    });
  }

  /**
   * Get auction extension history
   */
  async getExtensionHistory(listingId: number) {
    return prisma.auctionExtension.findMany({
      where: { listingId },
      orderBy: { createdAt: 'asc' },
    });
  }

  /**
   * Check and end expired auctions (for cron job)
   */
  async endExpiredAuctions() {
    const expiredAuctions = await prisma.listing.findMany({
      where: {
        isAuction: true,
        status: ListingStatus.ACTIVE,
        auctionEndsAt: { lte: new Date() },
      },
    });

    const results = [];
    for (const auction of expiredAuctions) {
      try {
        const result = await this.endAuction(auction.id);
        results.push({ success: true, auctionId: auction.id, result });
      } catch (error) {
        results.push({
          success: false,
          auctionId: auction.id,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    }

    return results;
  }
}
